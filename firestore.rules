rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is admin
    function isAdmin() {
      return request.auth != null
             && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Helper function to get user data
    function getUserData(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data;
    }

    // Users: authentication and role-based access control
    match /users/{userId} {
      allow create: if request.auth != null && (
                     // Allow self-registration as admin with required fields
                     (request.auth.uid == userId &&
                      request.resource.data.keys().hasAll(['email', 'role', 'uid', 'createdAt', 'societyId']) &&
                      request.resource.data.uid == request.auth.uid &&
                      request.resource.data.role == 'admin' &&
                      request.resource.data.keys().hasOnly(['email','role','uid','createdAt','societyId','displayName','provider','lastLogin'])) ||
                     // Admins can create users with explicit role
                     (isAdmin() &&
                      request.resource.data.keys().hasAll(['email', 'role', 'uid']) &&
                      request.resource.data.role in ['student', 'homeroom', 'admin'])
                   );
      
      allow read: if true;
      
      allow update: if request.auth != null &&
                     isAdmin() &&
                     request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['email', 'role', 'studentId', 'society', 'displayName', 'lastLogin', 'provider', 'societyId']);
      
      allow delete: if request.auth != null && isAdmin();
    }

    
    // Homerooms: created and managed by admins
    match /homerooms/{homeroomId} {
      allow create: if request.auth != null
                     && isAdmin()
                     && request.resource.data.keys().hasAll(['name','createdAt','adminUid'])
                     && request.resource.data.adminUid == request.auth.uid
                     && request.resource.data.keys().hasOnly(['name','code','createdAt','adminUid']);

      allow read: if request.auth != null && (
                    isAdmin() ||
                    resource.data.adminUid == request.auth.uid
                  );

      allow update: if request.auth != null &&
                     isAdmin() &&
                     request.resource.data.adminUid == resource.data.adminUid;

      allow delete: if request.auth != null && isAdmin();
    }

    // Fees: admin-managed contribution fees (applicable to all students)
    match /fees/{feeId} {
      // Admin creates a fee; remove society scoping so all students are applicable
      // Admin must include their societyId, which must match their users/{uid}.societyId
      allow create: if request.auth != null
                     && isAdmin()
                     && request.resource.data.keys().hasAll(['description', 'amount', 'createdAt', 'createdBy', 'societyId'])
                     && request.resource.data.createdBy == request.auth.uid
                     && request.resource.data.societyId == getUserData(request.auth.uid).societyId
                     && request.resource.data.amount is number
                     && request.resource.data.amount > 0
                     && request.resource.data.keys().hasOnly(['description', 'amount', 'createdAt', 'createdBy', 'societyId']);

      // Public can read fees to display in student portal
      allow read: if true;

      // Admin can update fee fields
      // Only allow updating description/amount; societyId and createdBy immutable
      allow update: if request.auth != null
                     && isAdmin()
                     && request.resource.data.diff(resource.data).changedKeys().hasOnly(['description', 'amount'])
                     && request.resource.data.amount is number
                     && request.resource.data.amount > 0
                     && request.resource.data.createdBy == resource.data.createdBy
                     && request.resource.data.societyId == resource.data.societyId;

      allow delete: if request.auth != null && isAdmin();

      allow list: if true;
    }

    // Payments: tracking with admin writes and public reads
    match /payments/{paymentId} {
      // Admin creates payments (e.g., batch assign for all students)
      allow create: if request.auth != null
                     && isAdmin()
                     && request.resource.data.keys().hasAll(['studentId', 'feeId', 'status', 'createdAt'])
                     && request.resource.data.status in ['paid', 'unpaid', 'pending']
                     && request.resource.data.keys().hasOnly(['studentId', 'feeId', 'status', 'createdAt', 'paidAt', 'paidBy', 'notes', 'societyId']);

      // Public read for student portal and outstanding reports
      allow read: if true;

      // Admin can mark payments paid/unpaid/pending and annotate
      allow update: if request.auth != null
                     && isAdmin()
                     && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'paidAt', 'paidBy', 'notes'])
                     && request.resource.data.status in ['paid', 'unpaid', 'pending']
                     && request.resource.data.studentId == resource.data.studentId
                     && request.resource.data.feeId == resource.data.feeId;

      allow delete: if request.auth != null && isAdmin();

      allow list: if true;
    }

    // Students: bulk admin creation for student records
    match /students/{studentId} {
      allow create: if request.auth != null
                     && isAdmin()
                     && request.resource.data.keys().hasAll(['studentId', 'createdAt', 'createdBy'])
                     && request.resource.data.createdBy == request.auth.uid
                     // societyId is optional; if provided it must match the admin's societyId
                     && ( !('societyId' in request.resource.data) || request.resource.data.societyId == getUserData(request.auth.uid).societyId )
                     && request.resource.data.keys().hasOnly(['studentId', 'societyId', 'society', 'firstName', 'lastName', 'middleName', 'createdAt', 'createdBy', 'programId', 'collegeId', 'yearLevelId', 'sectionId']);

      allow read: if request.auth != null && isAdmin();
      
      allow list: if request.auth != null && isAdmin();

      allow update: if request.auth != null && isAdmin();

      allow delete: if request.auth != null && isAdmin();
    }
  }
}
