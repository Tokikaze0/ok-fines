rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is admin
    function isAdmin() {
      return request.auth != null
             && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Helper function to get user data
    function getUserData(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data;
    }

    // Users: authentication and role-based access control
    match /users/{userId} {
      allow create: if request.auth != null && (
                     // Allow users to create their own account during registration
                     (request.auth.uid == userId &&
                      request.resource.data.keys().hasAll(['email', 'role', 'uid']) &&
                      request.resource.data.uid == request.auth.uid &&
                      request.resource.data.role in ['student', 'homeroom', 'admin']) ||
                     // Allow admins to create new users
                     (request.auth != null && 
                      isAdmin() &&
                      request.resource.data.keys().hasAll(['email', 'role', 'uid']) &&
                      request.resource.data.role in ['student', 'homeroom', 'admin'])
                   );
      
      allow read: if request.auth != null && (
                   // Users can read their own data
                   request.auth.uid == userId ||
                   // Admins can read all user data
                   isAdmin()
                 );
      
      allow update: if request.auth != null &&
                     isAdmin() &&
                     request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['email', 'role', 'studentId', 'society', 'displayName']);
      
      allow delete: if request.auth != null && isAdmin();
    }

    // Surveys: require authentication and validate fields
    match /surveys/{surveyId} {
      allow create: if request.auth != null
                   && request.resource.data.userId == request.auth.uid
                   && request.resource.data.keys().hasAll(['fullName', 'contact', 'rating', 'datetime', 'userId', 'latitude', 'longitude'])
                   && request.resource.data.rating in ['1','2','3','4','5']
                   && request.resource.data.latitude is number
                   && request.resource.data.longitude is number
                   && request.resource.data.latitude >= -90 && request.resource.data.latitude <= 90
                   && request.resource.data.longitude >= -180 && request.resource.data.longitude <= 180
                   && request.resource.data.keys().hasOnly(['fullName','contact','rating','comments','datetime','submittedAt','userId','latitude','longitude','imageUrl','imageData']);

      allow read: if request.auth != null && (
                    resource.data.userId == request.auth.uid ||
                    isAdmin()
                  );

      allow update: if request.auth != null && 
                     resource.data.userId == request.auth.uid;

      allow delete: if request.auth != null && (
                     resource.data.userId == request.auth.uid ||
                     isAdmin()
                   );
    }

    // Homerooms: created and managed by admins
    match /homerooms/{homeroomId} {
      allow create: if request.auth != null
                     && isAdmin()
                     && request.resource.data.keys().hasAll(['name','createdAt','adminUid'])
                     && request.resource.data.adminUid == request.auth.uid
                     && request.resource.data.keys().hasOnly(['name','code','createdAt','adminUid']);

      allow read: if request.auth != null && (
                    isAdmin() ||
                    resource.data.adminUid == request.auth.uid
                  );

      allow update: if request.auth != null &&
                     isAdmin() &&
                     request.resource.data.adminUid == resource.data.adminUid;

      allow delete: if request.auth != null && isAdmin();
    }

    // Fees: admin-managed contribution fees
    match /fees/{feeId} {
      allow create: if request.auth != null
                     && isAdmin()
                     && request.resource.data.keys().hasAll(['description', 'amount', 'createdAt', 'createdBy'])
                     && request.resource.data.createdBy == request.auth.uid
                     && request.resource.data.amount is number
                     && request.resource.data.amount > 0
                     && request.resource.data.keys().hasOnly(['description', 'amount', 'createdAt', 'createdBy']);

      allow read: if request.auth != null;

      allow update: if request.auth != null
                     && isAdmin()
                     && request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['description', 'amount'])
                     && request.resource.data.amount is number
                     && request.resource.data.amount > 0
                     && request.resource.data.createdBy == resource.data.createdBy;

      allow delete: if request.auth != null && isAdmin();

      allow list: if request.auth != null;
    }

    // Payments: payment tracking with granular access control
    match /payments/{paymentId} {
      allow create: if request.auth != null
                     && isAdmin()
                     && request.resource.data.keys().hasAll(['studentId', 'feeId', 'status', 'createdAt'])
                     && request.resource.data.status in ['paid', 'unpaid']
                     && request.resource.data.keys().hasOnly(['studentId', 'feeId', 'status', 'createdAt', 'paidAt', 'paidBy', 'notes']);

      allow read: if request.auth != null && (
                    // Admins can read all payments
                    isAdmin() ||
                    // Students can only read their own payments (filtered by studentId)
                    (resource.data.studentId == getUserData(request.auth.uid).studentId)
                  );

      allow update: if request.auth != null
                     && isAdmin()
                     && request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['status', 'paidAt', 'paidBy', 'notes'])
                     && request.resource.data.status in ['paid', 'unpaid']
                     && request.resource.data.studentId == resource.data.studentId
                     && request.resource.data.feeId == resource.data.feeId;

      allow delete: if request.auth != null && isAdmin();

      allow list: if request.auth != null;
    }

    // Students: bulk admin creation for student records
    match /students/{studentId} {
      allow create: if request.auth != null
                     && isAdmin()
                     && request.resource.data.keys().hasAll(['studentId', 'createdAt', 'createdBy'])
                     && request.resource.data.createdBy == request.auth.uid
                     // societyId is optional; if provided it must match the admin's societyId
                     && ( !('societyId' in request.resource.data) || request.resource.data.societyId == getUserData(request.auth.uid).societyId )
                     && request.resource.data.keys().hasOnly(['studentId', 'societyId', 'society', 'firstName', 'lastName', 'middleName', 'createdAt', 'createdBy', 'programId', 'collegeId', 'yearLevelId', 'sectionId']);

      allow read: if request.auth != null && isAdmin();
      
      allow list: if request.auth != null && isAdmin();

      allow update: if request.auth != null && isAdmin();

      allow delete: if request.auth != null && isAdmin();
    }
  }
}
